at::assert_no_internal_overlap ( result ) ; const Tensor * pnotSkippedTensor = [ ] ( const TensorList & tensors ) -> const Tensor * { for ( auto const & tensor : tensors ) { if ( should_skip ( tensor ) ) { continue ; 
e -> accept ( this ) ; if ( prec >= self_prec ) { os ( ) << ")" ; } } ; withParens ( v -> ret_val1 ( ) ) ; 
std::unordered_map < std::string , std::string > copied_metadata = owner_ -> metadata ( ) ; if ( owner_ -> metadata ( ) . find ( "model_name" ) == owner_ -> metadata ( ) . end ( ) ) { copied_metadata [ "model_name" ] = owner_ -> name ( ) ; } if ( observer ) { observer -> onEnterRunMethod ( copied_metadata , function_ -> name ( ) ) ; 
inline Variable valueToTensor ( c10::TensorOptions options , PyObject * value , const at::Device & device ) { if ( THPVariable_Check ( value ) ) { return THPVariable_Unpack ( value ) ; } 
if ( asyncErrorHandling_ ) { std::unique_lock<std::mutex> lock ( workMetaListMutex_ ) ; for ( auto & work : workMetaList_ ) { work . checkAndSetException ( ) ; if ( work . exception ( ) ) { continue ; } 
bool any_variable_defined ( const variable_list & variables ) { for ( const auto & variable : variables ) { if ( variable . defined ( ) ) { return true ; } 
hash_key_t static_hasher ( const LocalState & state , const at::Tensor & v ) { hash_key_t hash = { 1 , static_cast<int> ( packFlags ( state , v ) ) , static_cast<int> ( state . apply ( v . key_set ( ) ) . raw_repr ( ) ) , 
listenPort = ntohs ( addr -> sin6_port ) ; } else { TORCH_CHECK ( false , "unsupported protocol" ) ; } return listenPort ; } 
size_t idx = stack_ . back ( ) . toInt ( ) ; stack_ . pop_back ( ) ; TORCH_CHECK ( idx < globals_ . size ( ) , "Parsing error: out of bounds access to globals_" ) ; globals_ . at ( idx ) ( ) ; } break ; case PickleOpCode::BINPERSID : { 
int64_t output_zero_point ) { return apply_impl<true> ( input , output_scale , output_zero_point ) ; } 
void VImage::addImageMemoryBarrierToGeneral ( const VkCommandBuffer commandBuffer ) const { addImageMemoryBarrier ( commandBuffer , VK_IMAGE_LAYOUT_GENERAL ) ; } 
const py::object & compileFn , PyObject * args ) { std::vector<at::Tensor> tensorArgs = parsePythonArgs ( numArgs , args ) ; LocalState state ; hash_key_t cacheKey = computeCacheKey ( tensorArgs , numArgs , hasherType , id ) ; cache_ . emplace ( cacheKey , compileFn ) ; } 
case COMPRESS_ALL_BUFFERS : { auto buffers = BufFinder::find ( l . root_stmt ( ) ) ; message = "compressAllBuffers(l.root_stmt());n" ; randomization_helper::printHistory ( n_transform , message ) ; 
if ( ctx ) { std::unique_lock<std::mutex> cudaFreeMutexLock ( * ( c10::cuda::CUDACachingAllocator::getFreeMutex ( ) ) ) ; C10_CUDA_CHECK ( cudaFree ( nullptr ) ) ; } } 
std::vector<at::Tensor> & outputs , std::vector < std::vector<at::Tensor> > & inputs , const ReduceScatterOptions & opts ) { TORCH_CHECK ( false , "ProcessGroupGloo does not support reduce_scatter" ) ; } 
return { self . repeat ( sizes ) , nullopt } ; } VmapDimVector sizes_with_bdim = { sizes . begin ( ) , sizes . end ( ) } ; sizes_with_bdim . insert ( sizes_with_bdim . begin ( ) , 1 ) ; auto self_ = moveBatchDimToFront ( self , self_bdim ) ; while ( self_ . dim ( ) < sizes_with_bdim . size ( ) ) { self_ = self_ . unsqueeze ( 1 ) ; } return { self_ . repeat ( sizes_with_bdim ) , 0 } ; } 
auto result_stride_bytes = result . stride ( dim ) * elementSize ( result . scalar_type ( ) ) ; auto iter = TensorIteratorConfig ( ) . set_check_mem_overlap ( false ) . resize_outputs ( false ) . add_output ( result_slice ) . add_input ( source_slice ) 
work = c10::make_intrusive<AsyncAllgatherCUDAWork> ( std::move ( context ) , outputs , inputs , tag ) ; } else { TORCH_CHECK ( false , "Invalid backend" ) ; } enqueue ( work ) ; return work ; 
List < intrusive_ptr<ivalue::Future> > ( ctx -> srcFutures . elementType ( ) ) ; if ( src -> hasError ( ) ) { dst -> setError ( src -> exception_ptr ( ) ) ; } else { dst -> markCompleted ( src -> constValue ( ) ) ; } 
std::tuple < Tensor , Tensor > _symeig_helper_cpu ( const Tensor & self , bool eigenvectors , bool upper ) { auto infos = at::zeros ( { batchCount ( self ) } , self . options ( ) . dtype ( kInt ) ) ; auto self_sizes = self . sizes ( ) . vec ( ) ; self_sizes . pop_back ( ) ; 
SET roots ; for ( const auto & F : visibleFuncs ) { std::string name = _name ( F ) ; auto demangled = _demangle ( name ) ; if ( RootSymbolPatternLoc . pattern -> match ( demangled ) ) { roots . insert ( name ) ; 
static inline Tensor unary_op_impl_with_complex_to_float ( const Tensor & self , OutImpl & out_impl ) { if ( self . is_complex ( ) ) { const auto float_type = c10::toRealValueType ( self . scalar_type ( ) ) ; Tensor result = at::empty_like ( self , self . options ( ) . dtype ( float_type ) ) ; return out_impl ( result , self ) ; } 
line_end = start ( ) ; while ( line_start < range_end ) { while ( line_end < str . size ( ) && str [ line_end ] != 'n' ) { + line_end ; } 
public : template < typename scalar_t > constexpr void operator ( ) ( scalar_t * self_data , scalar_t * src_data ) const { * self_data = at::_isnan<scalar_t> ( * src_data ) * src_data : std::max ( * self_data , * src_data ) ; } } ; static ReduceMaximum reduce_maximum ; 
work = c10::make_intrusive<AsyncGatherCUDAWork> ( std::move ( context ) , outputs , inputs , opts . rootRank , tag ) ; } else { TORCH_CHECK ( false , "Invalid backend" ) ; } enqueue ( work ) ; return work ; 
if ( beta != scalar_t ( 1 ) && beta != scalar_t ( 0 ) ) scal<scalar_t> ( m , beta , y , incy ) ; for ( int64_t j = 0 ; j < n ; j ++ ) { scalar_t * column_ = a + lda * j ; scalar_t z = alpha * x [ j * incx ] ; for ( int64_t i = 0 ; i < m ; i ++ ) { if ( j == 0 && beta == scalar_t ( 0 ) ) { y [ i * incy ] = scalar_t ( 0 ) ; } y [ i * incy ] += z * column_ [ i ] ; } } 
work = c10::make_intrusive<AsyncGatherCUDAWork> ( std::move ( context ) , outputs , inputs , opts . rootRank , tag ) ; } else { TORCH_CHECK ( false , "Invalid backend" ) ; } enqueue ( work ) ; return work ; 
static PyObject * THPStorage_elementSize ( PyObject * _self , PyObject * noargs ) { HANDLE_TH_ERRORS return THPUtils_packInt64 ( sizeof ( uint8_t ) ) ; END_HANDLE_TH_ERRORS } 
cleanupKey_ ( "cleanup/" ) , regularPrefix_ ( "/" ) { if ( numWorkers_ < 1 ) { throw std::runtime_error ( "Number of workers for FileStore should be greater than zero" ) ; } } 
return per_bucket_variable_indices ; } std::vector<int64_t> Logger::get_bucket_sizes ( ) { std::vector<int64_t> bucket_sizes ; for ( const auto & bucket : reducer_ -> buckets_ ) { const auto & variables = bucket . variables ; int64_t bucket_size = 0 ; for ( const auto & v : variables ) { bucket_size += v . numel ( ) * v . element_size ( ) ; } 
def gen_returns ( returns : Tuple [ Return , . . . ] , cur_level_var : str , results_var : str ) -> str : idx = 0 wrapped_returns = [ ] for ret in returns : 
def draw_joint_graph ( graph , joint_inputs , file_name = "full_graph.png" ) : draw_graph ( graph , file_name ) return default_partition ( graph , joint_inputs ) def create_compiled_function ( flat_fn , fw_compiler , bw_compiler , partition_fn ) : joint_forward_backward = create_joint_forward_backward ( flat_fn ) 
def issubtype ( self , other ) : if isinstance ( other . param , _GenericAlias ) : if getattr ( other . param , origin__ None ) is Generic : return True if isinstance ( other , _DataPipeType ) : return issubtype ( self . param , other . param ) 
def write_bytes ( self , requests : List [ BytesWriteRequest ] ) -> Future [ None ] : for req in requests : with ( self . path / req . storage_key ) . open ( "wb" ) as w : w . write ( req . bytes . getbuffer ( ) ) os . fsync ( w . fileno ( ) ) fut : Future [ None ] = Future ( ) fut . set_result ( None ) return fut 
then we need to make sure get_attr is copied to the new graph . for x in flatten ( output_node . args [ 0 ] ) : if x . op == "get_attr" : setattr ( main_root , x . name , getattr_recursive ( gm , x . target ) ) type : ignore [ arg - type ] return torch . fx . GraphModule ( main_root , main_g ) 
self . _op_impls = set ( ) self . kind = kind self . dispatch_key = dispatch_key def __repr__ ( self ) : return "Library(kind={}, ns={}, dispatch_key={})>" . format ( self . kind , self . ns , self . dispatch_key ) 
self . scale = torch . tensor ( [ 1 . 0 ] ) self . zero_point = torch . tensor ( [ 0 ] ) self . dtype = self . activation_post_process . dtype self . qscheme = self . activation_post_process . qscheme 
tensor , scale , zero_point = unpacked_qtensors [ : 3 ] axis = unpacked_qtensors [ 3 ] if len ( unpacked_qtensors ) >= 4 else None axis_i = _get_const ( axis , "i" , "axis" ) input_scalar_type = tensor . type ( ) . scalarType ( ) assert input_scalar_type is not None input_qdtype = _type_utils . JitScalarType . from_name ( tensor . type ( ) . scalarType ( ) ) if qdtype is None : if input_qdtype is not None : 
model = copy . deepcopy ( model ) model . eval ( ) prepare ( model , inplace = True ) run_fn ( model , * run_args ) convert ( model , mapping , inplace = True ) return model 
env_callable = lambda fn : { "definitions" : [ ComputeUnboxingFunctions ( Target . DEFINITION , selector ) ( fn ) ] } , num_shards = 1 if selected_op_num < sharding_threshold else 5 , sharded_keys = { "definitions" } , ) cpu_fm . write ( 
elif isinstance ( real_out , list ) : return list ( [ wrap_with_proxy ( e , proxy_out [ idx ] ) for idx , e in enumerate ( real_out ) ] ) elif isinstance ( real_out , torch . Tensor ) : return wrap_with_proxy ( real_out , proxy_out ) else : return real_out 
def name ( func : FunctionSchema , * , faithful_name_for_out_overloads : bool = False ) -> str : name = str ( func . name . name ) if func . is_symint_fn ( ) : name += "_symint" if func . is_out_fn ( ) : 
def __str__ ( self ) -> str : all_arguments : List [ str ] = [ ] all_arguments . extend ( map ( str , self . flat_positional ) ) if self . flat_kwarg_only or self . out : all_arguments . append ( '*' ) all_arguments . extend ( map ( str , self . flat_kwarg_only ) ) all_arguments . extend ( map ( str , self . out ) ) return oin ( all_arguments ) 
for opt_tensor in optional_tensors : unwraps += unwrap_optional_tensor ( opt_tensor , cur_level_var ) unwrap_code = "n" . join ( unwraps ) unwrapped_arg_list = [ ] for arg in arg_names : 
tensor_rank = symbolic_helper . _get_tensor_rank ( self ) assert tensor_rank is not None unsqueeze_axes = list ( range ( 1 , tensor_rank + 1 ) ) expanded_boundaries = expand ( g , symbolic_helper . _unsqueeze_helper ( g , boundaries , unsqueeze_axes ) , 
register_decomposition ( aten . tanh_backward ) def tanh_backward_decomposition ( out_grad : Tensor , y : Tensor ) : return out_grad * ( 1 - y * y ) register_decomposition ( aten . sigmoid_backward ) def sigmoid_backward_decomposition ( out_grad : Tensor , y : Tensor ) : 
kwarg_only_set = set ( a . name for a in f . func . arguments . flat_kwarg_only ) out_arg_set = set ( a . name for a in f . func . arguments . out ) sig_group = CppSignatureGroup . from_schema ( f . func , method = False ) 
if found_tensor : n . meta [ nsor_meta = meta n . meta [ pe = type ( result ) return result 
def forward ( self , * args , * * kwargs ) : return compiled_f ( dict ( self . orig_module . named_parameters ( ) ) , dict ( self . orig_module . named_buffers ( ) ) , * args , * * kwargs ) 
def gen_vmap_plumbing ( native_function : NativeFunction ) -> Optional [ str ] : schema = native_function . func sig = DispatcherSignature . from_schema ( schema ) returns = schema . returns 
e1 = symbols [ n . args [ 0 ] ] we will propagate the runtime value here since this is regular addition c = Conj ( [ BinConstraintD ( my_output , BinConstraintD ( e1 , n . args [ 1 ] , op_code ) , op_eq ) , BinConstraintD ( 0 , my_output , op_leq ) ] ) return [ c ] , counter 
self . quant_min : int = quant_min self . quant_max : int = quant_max self . register_buffer ( "fake_quant_enabled" , torch . tensor ( [ 1 ] , dtype = torch . long ) ) self . register_buffer ( "observer_enabled" , torch . tensor ( [ 1 ] , dtype = torch . long ) ) self . is_symmetric_quant = _is_symmetric_quant ( self . activation_post_process . qscheme ) 
T = TypeVar ( 'T' , bound = ion [ _StorageBase , _TypedStorage ] class _StorageBase ( object ) : _cdata : Any is_sparse : bool = False is_sparse_csr : bool = False device : torch . device 
g = Graph ( ) output_vals = g . graph_copy ( self , val_map = memo , return_output_node = True ) assert isinstance ( output_vals , tuple ) output_val , old_output_val = output_vals g . output ( output_val , type_expr = getattr ( old_output_val , pe None ) ) return g 
